// Copyright (c) Bartłomiej Płotka @bwplotka
// Licensed under the Apache License 2.0.

package bingo

import (
	"io"
	"io/ioutil"
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"

	"github.com/pkg/errors"
	"golang.org/x/mod/modfile"
)

const (
	// FakeRootModFileName is a name for fake go module that we have to maintain, until https://github.com/bwplotka/bingo/issues/20 is fixed.
	FakeRootModFileName = "go.mod"
)

// NameFromModFile returns binary name from module file path.
func NameFromModFile(modFile string) (name string, oneOfMany bool) {
	n := strings.Split(strings.TrimSuffix(filepath.Base(modFile), ".mod"), ".")
	if len(n) > 1 {
		oneOfMany = true
	}
	return n[0], oneOfMany
}

func readAllFileOrReader(modFile string, r io.Reader) (b []byte, err error) {
	if r != nil {
		return ioutil.ReadAll(r)
	}
	return ioutil.ReadFile(modFile)
}

// ModDirectPackage returns buildable package we encoded in the bingo controlled go module.
// We encode it as single direct module with end of line comment containing relative package path if any.
// If r is nil, modFile will be read.
// If given file is Go Module, but without bingo metadata bingo.NoMeta error is returned.
func ModDirectPackage(modFile string, r io.Reader) (pkg string, version string, err error) {
	b, err := readAllFileOrReader(modFile, r)
	if err != nil {
		return "", "", errors.Wrap(err, "read")
	}

	m, err := modfile.Parse(modFile, b, nil)
	if err != nil {
		return "", "", errors.Wrap(err, "parse")
	}

	if err := onModHeaderComments(m, errOnMetaMissing); err != nil {
		return "", "", err
	}

	// We expect just one direct import.
	for _, r := range m.Require {
		if r.Indirect {
			continue
		}

		pkg := r.Mod.Path
		if len(r.Syntax.Suffix) > 0 {
			pkg = path.Join(pkg, strings.Trim(r.Syntax.Suffix[0].Token[3:], "\n"))
		}
		return pkg, r.Mod.Version, nil
	}
	return "", "", errors.Errorf("empty or malformed module file %v", modFile)
}

const metaComment = "// Auto generated by https://github.com/bwplotka/bingo. DO NOT EDIT"

func onModHeaderComments(m *modfile.File, f func(*modfile.Comments) error) error {
	if m.Module == nil {
		return errors.New("failed to parse; no module")
	}
	if m.Module.Syntax == nil {
		return errors.New("failed to parse; no module's syntax")
	}
	if m.Module.Syntax.Comment() == nil {
		return errors.Errorf("expected %q comment on top of module, found no comment", metaComment)
	}
	return f(m.Module.Syntax.Comment())
}

func errOnMetaMissing(comments *modfile.Comments) error {
	for _, c := range comments.Suffix {
		tr := strings.Trim(c.Token, "\n")
		if tr != metaComment {
			return errors.Errorf("expected %q comment on top of module, found %q", metaComment, tr)
		}
	}
	return nil
}

// EnsureModMeta comment on given module file to make sure users knows it's autogenerated.
// It also ensures that sub package path is recorded, which is required for package-level versioning.
func EnsureModMeta(modFile string, pkg string) (err error) {
	f, err := os.OpenFile(modFile, os.O_RDWR, os.ModePerm)
	if err != nil {
		return err
	}
	defer func() {
		if cerr := f.Close(); cerr != nil {
			if err != nil {
				err = errors.Wrapf(err, "additionally error on close: %v", cerr)
				return
			}
			err = cerr
		}
	}()
	b, err := ioutil.ReadAll(f)
	if err != nil {
		return err
	}

	m, err := modfile.Parse(modFile, b, nil)
	if err != nil {
		return errors.Wrap(err, "failed to parse")
	}

	if err := onModHeaderComments(m, func(comments *modfile.Comments) error {
		if err := errOnMetaMissing(comments); err != nil {
			m.Module.Syntax.Suffix = append(m.Module.Syntax.Suffix, modfile.Comment{Suffix: true, Token: metaComment})
		}
		return nil
	}); err != nil {
		return err
	}

	for _, r := range m.Require {
		if !strings.HasPrefix(pkg, r.Mod.Path) {
			continue
		}

		r.Syntax.Suffix = r.Syntax.Suffix[:0]

		// Add sub package info if needed.
		if r.Mod.Path != pkg {
			subPkg, err := filepath.Rel(r.Mod.Path, pkg)
			if err != nil {
				return err
			}
			r.Syntax.Suffix = append(r.Syntax.Suffix, modfile.Comment{Suffix: true, Token: "// " + subPkg})
		}

		// Save & Flush.
		newB, err := m.Format()
		if err != nil {
			return err
		}

		if err := f.Truncate(0); err != nil {
			return errors.Wrap(err, "truncate")
		}
		if _, err := f.Seek(0, 0); err != nil {
			return errors.Wrap(err, "seek")
		}

		_, err = f.Write(newB)
		return err
	}
	return errors.Errorf("empty module found in %s", modFile)
}

type MainPackageVersion struct {
	Version string
	ModFile string
}

type MainPackage struct {
	Name        string
	PackagePath string
	EnvVarName  string
	Versions    []MainPackageVersion
}

// ListPinnedMainPackages lists all bingo pinned binaries (Go main packages).
func ListPinnedMainPackages(logger *log.Logger, modDir string, remMalformed bool) (pkgs []MainPackage, _ error) {
	modFiles, err := filepath.Glob(filepath.Join(modDir, "*.mod"))
	if err != nil {
		return nil, err
	}
ModLoop:
	for _, f := range modFiles {
		if filepath.Base(f) == FakeRootModFileName {
			continue
		}

		pkg, ver, err := ModDirectPackage(f, nil)
		if err != nil {
			if remMalformed {
				logger.Printf("found malformed module file %v, removing due to error: %v\n", f, err)
				if err := os.RemoveAll(strings.TrimSuffix(f, ".") + "*"); err != nil {
					return nil, err
				}
			}
			continue
		}

		name, _ := NameFromModFile(f)
		varName := strings.ReplaceAll(strings.ReplaceAll(strings.ToUpper(name), ".", "_"), "-", "_")
		for i, p := range pkgs {
			if p.Name == name {
				pkgs[i].EnvVarName = varName + "_ARRAY"
				// Preserve order. Unfortunately first array mod file has no number, so it's last.
				if filepath.Base(f) == p.Name+".mod" {
					pkgs[i].Versions = append([]MainPackageVersion{{
						Version: ver,
						ModFile: filepath.Base(f),
					}}, pkgs[i].Versions...)
					continue ModLoop
				}

				pkgs[i].Versions = append(pkgs[i].Versions, MainPackageVersion{
					Version: ver,
					ModFile: filepath.Base(f),
				})
				continue ModLoop
			}
		}
		pkgs = append(pkgs, MainPackage{
			Name: name,
			Versions: []MainPackageVersion{
				{Version: ver, ModFile: filepath.Base(f)},
			},
			EnvVarName:  varName,
			PackagePath: pkg,
		})
	}
	return pkgs, nil
}
